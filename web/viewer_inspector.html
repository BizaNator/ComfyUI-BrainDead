<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>BD Mesh Inspector</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            overflow: hidden;
            background: #1a1a1a;
            font-family: -apple-system, BlinkMacSystemFont, monospace;
        }
        #toolbar {
            position: absolute;
            top: 0; left: 0; right: 0;
            background: rgba(26, 26, 26, 0.92);
            padding: 5px 8px;
            display: flex;
            gap: 3px;
            z-index: 10;
            flex-wrap: wrap;
            border-bottom: 1px solid #333;
        }
        #toolbar button {
            background: #2a2a2a;
            color: #999;
            border: 1px solid #444;
            padding: 3px 7px;
            font-size: 10px;
            font-family: monospace;
            cursor: pointer;
            border-radius: 3px;
            transition: all 0.15s;
        }
        #toolbar button:hover {
            background: #3a3a3a;
            color: #ccc;
        }
        #toolbar button.active {
            background: #2a6cb8;
            color: #fff;
            border-color: #4a9eff;
        }
        #toolbar button.unavailable {
            opacity: 0.35;
            cursor: not-allowed;
        }
        #canvas {
            width: 100%;
            height: 100%;
            display: block;
        }
        #info {
            position: absolute;
            bottom: 4px;
            left: 8px;
            color: #555;
            font-size: 9px;
            font-family: monospace;
            pointer-events: none;
        }
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #666;
            font-size: 12px;
            font-family: monospace;
            text-align: center;
        }
    </style>
</head>
<body>
    <div id="toolbar">
        <button data-mode="full_material" class="active">Material</button>
        <button data-mode="geometry">Geometry</button>
        <button data-mode="vertex_colors">Colors</button>
        <button data-mode="uv" class="unavailable">UV</button>
        <button data-mode="normal">Normal</button>
        <button data-mode="metallic" class="unavailable">Metallic</button>
        <button data-mode="roughness" class="unavailable">Roughness</button>
        <button data-mode="alpha">Alpha</button>
        <button data-mode="emissive" class="unavailable">Emissive</button>
        <button data-mode="diffuse" class="unavailable">Diffuse</button>
    </div>
    <canvas id="canvas"></canvas>
    <div id="loading">BD Mesh Inspector</div>
    <div id="info"></div>

    <!-- Local Three.js bundle (offline capable) -->
    <script src="./js/three-inspector-bundle.js"></script>

    <script>
        // Globals from bundle: THREE, OrbitControls, GLTFLoader
        const canvas = document.getElementById('canvas');
        const loading = document.getElementById('loading');
        const info = document.getElementById('info');
        const toolbar = document.getElementById('toolbar');

        // ========== Scene Setup ==========
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x1a1a1a);

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.01, 1000);
        camera.position.set(2, 1.5, 2);

        const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.outputColorSpace = THREE.SRGBColorSpace;

        const controls = new OrbitControls(camera, canvas);
        controls.enableDamping = true;
        controls.dampingFactor = 0.08;
        controls.zoomSpeed = 2.5;

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);

        const dirLight1 = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight1.position.set(5, 8, 6);
        scene.add(dirLight1);

        const dirLight2 = new THREE.DirectionalLight(0xffffff, 0.3);
        dirLight2.position.set(-4, -3, -5);
        scene.add(dirLight2);

        // Grid + axes
        const grid = new THREE.GridHelper(10, 20, 0x333333, 0x222222);
        scene.add(grid);

        const axes = new THREE.AxesHelper(0.5);
        scene.add(axes);

        // ========== State ==========
        let loadedMesh = null;
        let originalMaterials = new Map();
        let currentMode = 'full_material';
        let channelData = {
            metallic: null,
            roughness: null,
            normal_map_b64: null,
            emissive_map_b64: null,
            alpha_map_b64: null,
            diffuse_map_b64: null,
            metallic_map_b64: null,
            roughness_map_b64: null,
            vertex_colors_b64: null,
            has_uvs: false,
            has_colors: false,
        };

        // ========== Animation Loop ==========
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // ========== Toolbar ==========
        toolbar.addEventListener('click', (e) => {
            const btn = e.target.closest('button');
            if (!btn || btn.classList.contains('unavailable')) return;
            const mode = btn.dataset.mode;
            if (mode) switchMode(mode);
        });

        function updateToolbar(mode) {
            toolbar.querySelectorAll('button').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.mode === mode);
            });
        }

        function updateAvailability() {
            // Check if any mesh child has UVs
            let meshHasUVs = channelData.has_uvs;
            if (loadedMesh && !meshHasUVs) {
                loadedMesh.traverse((child) => {
                    if (child.isMesh && child.geometry && child.geometry.attributes.uv) {
                        meshHasUVs = true;
                    }
                });
            }

            // Check if vertex colors available (from geometry OR from bundle data)
            let meshHasColors = channelData.has_colors || !!channelData.vertex_colors_b64;
            if (!meshHasColors && loadedMesh) {
                loadedMesh.traverse((child) => {
                    if (child.isMesh && child.geometry && child.geometry.attributes.color) {
                        meshHasColors = true;
                    }
                });
            }

            toolbar.querySelectorAll('button').forEach(btn => {
                const mode = btn.dataset.mode;
                let available = true;
                if (mode === 'vertex_colors') available = meshHasColors;
                if (mode === 'metallic') available = (channelData.metallic && channelData.metallic.length > 0) || !!channelData.metallic_map_b64;
                if (mode === 'roughness') available = (channelData.roughness && channelData.roughness.length > 0) || !!channelData.roughness_map_b64;
                if (mode === 'emissive') available = !!channelData.emissive_map_b64;
                if (mode === 'diffuse') available = !!channelData.diffuse_map_b64;
                if (mode === 'uv') available = meshHasUVs;
                btn.classList.toggle('unavailable', !available);
            });
        }

        // ========== Mode Switching ==========
        function switchMode(mode) {
            if (!loadedMesh) return;
            currentMode = mode;
            updateToolbar(mode);

            loadedMesh.traverse((child) => {
                if (!child.isMesh) return;

                // Dispose current material if it's not original
                if (child.material && !originalMaterials.has(child.material)) {
                    if (child.material.dispose) child.material.dispose();
                }

                switch (mode) {
                    case 'full_material':
                        child.material = originalMaterials.get(child) || new THREE.MeshStandardMaterial({
                            vertexColors: !!(child.geometry && child.geometry.attributes.color),
                            metalness: 0.1, roughness: 0.8
                        });
                        break;

                    case 'geometry':
                        child.material = new THREE.MeshBasicMaterial({
                            wireframe: true,
                            color: 0x4a9eff,
                            transparent: true,
                            opacity: 0.8,
                        });
                        break;

                    case 'vertex_colors':
                        if (child.geometry && child.geometry.attributes.color) {
                            child.material = new THREE.MeshBasicMaterial({ vertexColors: true });
                        } else if (channelData.vertex_colors_b64) {
                            // Apply vertex colors from bundle data
                            applyBundleVertexColors(child, channelData.vertex_colors_b64);
                        } else {
                            child.material = new THREE.MeshBasicMaterial({ color: 0x222222 });
                        }
                        break;

                    case 'uv':
                        if (child.geometry.attributes.uv) {
                            child.material = new THREE.ShaderMaterial({
                                vertexShader: `
                                    varying vec2 vUv;
                                    void main() {
                                        vUv = uv;
                                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                                    }
                                `,
                                fragmentShader: `
                                    varying vec2 vUv;
                                    void main() {
                                        // UV → color: R=U, G=V, B=checkerboard for orientation
                                        float checker = mod(floor(vUv.x * 8.0) + floor(vUv.y * 8.0), 2.0) * 0.15;
                                        gl_FragColor = vec4(
                                            fract(vUv.x),
                                            fract(vUv.y),
                                            checker + 0.1,
                                            1.0
                                        );
                                    }
                                `,
                            });
                        } else {
                            child.material = new THREE.MeshBasicMaterial({ color: 0x332200 });
                        }
                        break;

                    case 'normal':
                        if (channelData.normal_map_b64) {
                            applyTextureToMesh(child, channelData.normal_map_b64);
                        } else {
                            child.material = new THREE.ShaderMaterial({
                                vertexShader: `
                                    varying vec3 vNormal;
                                    void main() {
                                        vNormal = normalize(normalMatrix * normal);
                                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                                    }
                                `,
                                fragmentShader: `
                                    varying vec3 vNormal;
                                    void main() {
                                        gl_FragColor = vec4(vNormal * 0.5 + 0.5, 1.0);
                                    }
                                `,
                            });
                        }
                        break;

                    case 'metallic':
                        if (channelData.metallic_map_b64) {
                            applyTextureToMesh(child, channelData.metallic_map_b64);
                        } else {
                            applyScalarChannel(child, channelData.metallic);
                        }
                        break;

                    case 'roughness':
                        if (channelData.roughness_map_b64) {
                            applyTextureToMesh(child, channelData.roughness_map_b64);
                        } else {
                            applyScalarChannel(child, channelData.roughness);
                        }
                        break;

                    case 'alpha':
                        if (channelData.alpha_map_b64) {
                            applyTextureToMesh(child, channelData.alpha_map_b64);
                        } else {
                            applyAlphaFromVertexColors(child);
                        }
                        break;

                    case 'emissive':
                        if (channelData.emissive_map_b64) {
                            applyTextureToMesh(child, channelData.emissive_map_b64);
                        } else {
                            child.material = new THREE.MeshBasicMaterial({ color: 0x111111 });
                        }
                        break;

                    case 'diffuse':
                        if (channelData.diffuse_map_b64) {
                            applyTextureToMesh(child, channelData.diffuse_map_b64);
                        } else {
                            child.material = new THREE.MeshBasicMaterial({ color: 0x333333 });
                        }
                        break;
                }
            });

            updateInfo();
        }

        // ========== Channel Application Helpers ==========

        function applyScalarChannel(meshChild, valuesArray) {
            if (!valuesArray || valuesArray.length === 0) {
                meshChild.material = new THREE.MeshBasicMaterial({ color: 0x333333 });
                return;
            }

            const geometry = meshChild.geometry;
            const count = geometry.attributes.position.count;
            const colors = new Float32Array(count * 3);

            for (let i = 0; i < count; i++) {
                const val = i < valuesArray.length ? valuesArray[i] : 0;
                colors[i * 3] = val;
                colors[i * 3 + 1] = val;
                colors[i * 3 + 2] = val;
            }

            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            geometry.attributes.color.needsUpdate = true;
            meshChild.material = new THREE.MeshBasicMaterial({ vertexColors: true });
        }

        function applyAlphaFromVertexColors(meshChild) {
            const geometry = meshChild.geometry;
            const colorAttr = geometry.attributes.color;

            if (!colorAttr) {
                meshChild.material = new THREE.MeshBasicMaterial({ color: 0xffffff });
                return;
            }

            const count = geometry.attributes.position.count;
            const colors = new Float32Array(count * 3);
            const itemSize = colorAttr.itemSize;

            for (let i = 0; i < count; i++) {
                // Alpha is the 4th component (index 3) if RGBA, else default to 1.0
                const alpha = itemSize >= 4 ? colorAttr.getW(i) : 1.0;
                colors[i * 3] = alpha;
                colors[i * 3 + 1] = alpha;
                colors[i * 3 + 2] = alpha;
            }

            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            geometry.attributes.color.needsUpdate = true;
            meshChild.material = new THREE.MeshBasicMaterial({ vertexColors: true });
        }

        function applyBundleVertexColors(meshChild, b64Data) {
            // Decode base64 RGBA uint8 bytes → Float32 RGB vertex colors
            try {
                const binary = atob(b64Data);
                const bytes = new Uint8Array(binary.length);
                for (let i = 0; i < binary.length; i++) {
                    bytes[i] = binary.charCodeAt(i);
                }

                const vertexCount = meshChild.geometry.attributes.position.count;
                const numPixels = bytes.length / 4; // RGBA = 4 bytes per vertex
                const count = Math.min(vertexCount, numPixels);

                const colors = new Float32Array(vertexCount * 3);
                for (let i = 0; i < count; i++) {
                    colors[i * 3] = bytes[i * 4] / 255;       // R
                    colors[i * 3 + 1] = bytes[i * 4 + 1] / 255; // G
                    colors[i * 3 + 2] = bytes[i * 4 + 2] / 255; // B
                }

                meshChild.geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                meshChild.geometry.attributes.color.needsUpdate = true;
                meshChild.material = new THREE.MeshBasicMaterial({ vertexColors: true });
                console.log(`[BD Inspector] Applied ${count} vertex colors from bundle`);
            } catch (e) {
                console.error('[BD Inspector] Failed to apply vertex colors:', e);
                meshChild.material = new THREE.MeshBasicMaterial({ color: 0x222222 });
            }
        }

        function applyTextureToMesh(meshChild, base64Data) {
            const img = new Image();
            img.onload = () => {
                const texture = new THREE.Texture(img);
                texture.needsUpdate = true;
                texture.colorSpace = THREE.SRGBColorSpace;
                // glTF uses top-left UV origin, so flipY must be false for GLB-loaded meshes
                texture.flipY = false;
                meshChild.material = new THREE.MeshBasicMaterial({ map: texture });
            };
            img.src = `data:image/png;base64,${base64Data}`;
        }

        // ========== Info Bar ==========
        function updateInfo() {
            if (!loadedMesh) {
                info.textContent = '';
                return;
            }
            let verts = 0, faces = 0;
            loadedMesh.traverse((child) => {
                if (child.isMesh && child.geometry) {
                    verts += child.geometry.attributes.position.count;
                    if (child.geometry.index) {
                        faces += child.geometry.index.count / 3;
                    }
                }
            });
            const modeLabel = currentMode.replace(/_/g, ' ');
            info.textContent = `${verts.toLocaleString()} verts | ${faces.toLocaleString()} faces | ${modeLabel}`;
        }

        // ========== Mesh Loading ==========
        function loadMesh(filepath, initialMode) {
            loading.textContent = 'Loading mesh...';
            loading.style.display = 'block';

            // Remove old mesh
            if (loadedMesh) {
                scene.remove(loadedMesh);
                loadedMesh.traverse((child) => {
                    if (child.geometry) child.geometry.dispose();
                    if (child.material) {
                        if (Array.isArray(child.material)) {
                            child.material.forEach(m => m.dispose());
                        } else {
                            child.material.dispose();
                        }
                    }
                });
                loadedMesh = null;
                originalMaterials.clear();
            }

            const loader = new GLTFLoader();
            loader.load(
                filepath,
                (gltf) => {
                    loadedMesh = gltf.scene;

                    // Center mesh
                    const box = new THREE.Box3().setFromObject(loadedMesh);
                    const center = box.getCenter(new THREE.Vector3());
                    loadedMesh.position.sub(center);

                    // Store original materials - only enable vertex colors if geometry has them
                    loadedMesh.traverse((child) => {
                        if (child.isMesh) {
                            const hasVertexColors = child.geometry && child.geometry.attributes.color;
                            if (!child.material) {
                                child.material = new THREE.MeshStandardMaterial({
                                    vertexColors: hasVertexColors,
                                    metalness: 0.1,
                                    roughness: 0.8,
                                });
                            } else if (hasVertexColors) {
                                // Only enable vertex colors if geometry actually has color attribute
                                if (child.material.isMeshStandardMaterial || child.material.isMeshPhysicalMaterial) {
                                    child.material.vertexColors = true;
                                    child.material.needsUpdate = true;
                                }
                            }
                            originalMaterials.set(child, child.material.clone());
                        }
                    });

                    scene.add(loadedMesh);

                    // Adjust camera to fit
                    const size = box.getSize(new THREE.Vector3());
                    const maxDim = Math.max(size.x, size.y, size.z);
                    const distance = maxDim * 2.2;
                    camera.position.set(distance * 0.7, distance * 0.5, distance * 0.7);
                    camera.lookAt(0, 0, 0);
                    controls.target.set(0, 0, 0);
                    camera.near = maxDim * 0.001;
                    camera.far = maxDim * 100;
                    camera.updateProjectionMatrix();
                    controls.update();

                    loading.style.display = 'none';
                    updateAvailability();
                    switchMode(initialMode || 'full_material');
                },
                (progress) => {
                    if (progress.lengthComputable) {
                        const pct = Math.round(progress.loaded / progress.total * 100);
                        loading.textContent = `Loading... ${pct}%`;
                    }
                },
                (error) => {
                    console.error('[BD Inspector] Load error:', error);
                    loading.textContent = 'Error loading mesh';
                    loading.style.color = '#f66';
                }
            );
        }

        // ========== Message Handler ==========
        window.addEventListener('message', (event) => {
            const data = event.data;
            if (data.type !== 'LOAD_INSPECTOR_MESH') return;

            // Store channel data
            try {
                channelData.metallic = data.metallic_json ? JSON.parse(data.metallic_json) : null;
            } catch (e) { channelData.metallic = null; }

            try {
                channelData.roughness = data.roughness_json ? JSON.parse(data.roughness_json) : null;
            } catch (e) { channelData.roughness = null; }

            channelData.normal_map_b64 = data.normal_map_b64 || null;
            channelData.emissive_map_b64 = data.emissive_map_b64 || null;
            channelData.alpha_map_b64 = data.alpha_map_b64 || null;
            channelData.diffuse_map_b64 = data.diffuse_map_b64 || null;
            channelData.metallic_map_b64 = data.metallic_map_b64 || null;
            channelData.roughness_map_b64 = data.roughness_map_b64 || null;
            channelData.vertex_colors_b64 = data.vertex_colors_b64 || null;
            channelData.has_uvs = data.has_uvs || false;
            channelData.has_colors = data.has_colors || false;

            // Load the mesh
            loadMesh(data.filepath, data.initial_mode);
        });

        console.log('[BD Inspector] Viewer ready');
    </script>
</body>
</html>
